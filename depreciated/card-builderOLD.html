<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
    
</head>
<body>

    <div class="sidebar">
        <h2 style="color:var(--accent)">VIRTUAL SPORTS CARDS v.0.1</h2>
        
        <div class="section">
            <label>Card Visuals</label>
            <label><input type="checkbox" id="isHolo" checked style="width:auto"> Holographic Foil</label>
            <label><input type="checkbox" id="isAllStar" checked style="width:auto"> All-Star Status</label>
            <input type="text" id="mint" value="1/100" placeholder="Mint #">
        </div>

        <div class="section">
            <label>Front Artwork</label>
            <input type="file" id="imgFront" accept="image/*">
            <input type="text" id="fName" value="Amonte">
            <input type="text" id="lName" value="Dubois-Smith">
            <input type="text" id="team" value="Pittsburgh Riverhogs">
            <input type="color" id="themeColor" value="#facc15">
        </div>

        <div class="section">
            <label>Back Customization</label>
            <input type="file" id="imgBack" accept="image/*">
            <input type="color" id="backColor" value="#f8fafc">
            <textarea id="quote" rows="2">"A defensive powerhouse with unmatched field vision."</textarea>
            <div style="display:grid; grid-template-columns: 1fr 1fr; gap:5px;">
                <input type="number" id="spd" value="92" placeholder="SPD">
                <input type="number" id="agi" value="88" placeholder="AGI">
                <input type="number" id="str" value="85" placeholder="STR">
                <input type="number" id="con" value="95" placeholder="CON">
            </div>
        </div>

        <button class="btn btn-primary" onclick="updateCard()">Update Preview</button>
        <button class="btn btn-flip" onclick="flipCard()">Flip Card</button>
        <button class="btn btn-download" onclick="downloadCard()">Download Front</button>
    </div>

    <div id="viewport"></div>

    <canvas id="hidden-canvas-front" width="1024" height="1480"></canvas>
    <canvas id="hidden-canvas-back" width="1024" height="1480"></canvas>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        let scene, camera, renderer, cardMesh;
        let isFlipped = false;
        let userImages = { front: null, back: null };

        // HELPER FUNCTIONS (Moved to top for safety)
        function drawR(ctx, x, y, w, h, r, fill, stroke) {
            ctx.beginPath();
            ctx.moveTo(x+r, y);
            ctx.lineTo(x+w-r, y);
            ctx.quadraticCurveTo(x+w, y, x+w, y+r);
            ctx.lineTo(x+w, y+h-r);
            ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
            ctx.lineTo(x+r, y+h);
            ctx.quadraticCurveTo(x, y+h, x, y+h-r);
            ctx.lineTo(x, y+r);
            ctx.quadraticCurveTo(x, y, x+r, y);
            ctx.closePath();
            if(fill) ctx.fill();
            if(stroke) ctx.stroke();
        }

        function drawStar(ctx, cx, cy, spikes, outerRadius, innerRadius) {
            let rot = Math.PI/2*3, x=cx, y=cy, step=Math.PI/spikes;
            ctx.beginPath(); ctx.moveTo(cx, cy-outerRadius);
            for(let i=0;i<spikes;i++){
                x=cx+Math.cos(rot)*outerRadius; y=cy+Math.sin(rot)*outerRadius; ctx.lineTo(x,y); rot+=step;
                x=cx+Math.cos(rot)*innerRadius; y=cy+Math.sin(rot)*innerRadius; ctx.lineTo(x,y); rot+=step;
            }
            ctx.lineTo(cx, cy-outerRadius); ctx.closePath(); ctx.fill();
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(35, (window.innerWidth - 360) / window.innerHeight, 0.1, 1000);
            camera.position.z = 12;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth - 360, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('viewport').appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.8));
            const light = new THREE.DirectionalLight(0xffffff, 0.5);
            light.position.set(5, 5, 10);
            scene.add(light);

            setupInteraction();
            bindInput('imgFront', 'front');
            bindInput('imgBack', 'back');
        }

        function bindInput(id, key) {
            document.getElementById(id).addEventListener('change', e => {
                const reader = new FileReader();
                reader.onload = ev => {
                    const img = new Image();
                    img.onload = () => { userImages[key] = img; updateCard(); };
                    img.src = ev.target.result;
                };
                reader.readAsDataURL(e.target.files[0]);
            });
        }

        function drawFront() {
            const canvas = document.getElementById('hidden-canvas-front');
            const ctx = canvas.getContext('2d');
            const theme = document.getElementById('themeColor').value;
            const w = 1024, h = 1480;

            ctx.clearRect(0,0,w,h);
            ctx.fillStyle = '#fffdf0'; ctx.fillRect(0,0,w,h);
            
            if (userImages.front) {
                ctx.drawImage(userImages.front, 0, 0, w, h);
            }

            // Border
            ctx.strokeStyle = theme; ctx.lineWidth = 45;
            drawR(ctx, 40, 40, w-80, h-80, 60, false, true);
            ctx.strokeStyle = '#fff'; ctx.lineWidth = 15;
            drawR(ctx, 60, 60, w-120, h-120, 50, false, true);

            if(document.getElementById('isAllStar').checked) {
                ctx.fillStyle = theme;
                drawStar(ctx, 160, 160, 5, 70, 30);
                ctx.strokeStyle = '#000'; ctx.lineWidth = 4; ctx.stroke();
            }

            // Banner
            ctx.fillStyle = '#111';
            ctx.beginPath(); ctx.moveTo(0, h-320); ctx.lineTo(480, h-260); ctx.lineTo(480, h-180); ctx.lineTo(0, h-240); ctx.fill();
            ctx.fillStyle = '#fff'; ctx.font = 'bold 36px Arial'; ctx.textAlign = 'left';
            ctx.fillText(document.getElementById('team').value.toUpperCase(), 45, h-245);

            // Name Plate
            ctx.fillStyle = '#fffdf0';
            ctx.beginPath(); ctx.moveTo(50, h-160); ctx.lineTo(w, h-260); ctx.lineTo(w, h-60); ctx.lineTo(50, h+40); ctx.fill();
            ctx.fillStyle = '#222'; ctx.textAlign = 'right'; ctx.font = 'italic 900 75px Georgia';
            ctx.fillText(document.getElementById('lName').value, w-80, h-120);
            
            ctx.textAlign = 'left'; ctx.font = 'bold 30px Courier';
            ctx.fillText(document.getElementById('mint').value, 80, h-60);
        }

        function drawBack() {
            const canvas = document.getElementById('hidden-canvas-back');
            const ctx = canvas.getContext('2d');
            const theme = document.getElementById('themeColor').value;
            const bg = document.getElementById('backColor').value;
            const w = 1024, h = 1480;

            ctx.fillStyle = bg; ctx.fillRect(0,0,w,h);
            if (userImages.back) { 
                ctx.globalAlpha = 0.3; 
                ctx.drawImage(userImages.back, 0, 0, w, h); 
                ctx.globalAlpha = 1; 
            }
            
            ctx.strokeStyle = theme; ctx.lineWidth = 40; ctx.strokeRect(0,0,w,h);
            ctx.fillStyle = theme; ctx.textAlign = 'center'; ctx.font = 'bold 55px Arial'; ctx.fillText(document.getElementById('fName').value + " " + document.getElementById('lName').value, w/2, 130);

            const stats = [
                {l: 'SPEED', v: document.getElementById('spd').value},
                {l: 'AGILITY', v: document.getElementById('agi').value},
                {l: 'STRENGTH', v: document.getElementById('str').value},
                {l: 'CONSISTENCY', v: document.getElementById('con').value}
            ];
            stats.forEach((s, i) => {
                let y = 320 + (i * 140);
                ctx.textAlign = 'left'; ctx.fillStyle = '#64748b'; ctx.font = 'bold 32px Arial'; ctx.fillText(s.l, 120, y);
                ctx.textAlign = 'right'; ctx.fillStyle = '#000'; ctx.fillText(s.v, w-120, y);
                ctx.fillStyle = '#cbd5e1'; ctx.fillRect(120, y+20, w-240, 20);
                ctx.fillStyle = theme; ctx.fillRect(120, y+20, (s.v/100)*(w-240), 20);
            });
            ctx.textAlign = 'center'; ctx.fillStyle = '#1e293b'; ctx.font = 'italic 40px Georgia';
            ctx.fillText(`"${document.getElementById('quote').value}"`, w/2, 950);
        }

        updateCard(vaultData = null) {
    if (!window.CardApp || !window.CardRenderer) return;
    const data = vaultData || window.UIHandler.getFormData();
    
    window.CardRenderer.renderFront(data, this.userImages);
    window.CardRenderer.renderBack(data, this.userImages);

    const texF = new THREE.CanvasTexture(document.getElementById('hidden-canvas-front'));
    const texB = new THREE.CanvasTexture(document.getElementById('hidden-canvas-back'));
    const texP = new THREE.CanvasTexture(document.getElementById('hidden-canvas-player'));
    const texBorder = new THREE.CanvasTexture(document.getElementById('hidden-canvas-border'));

    [texF, texB, texP, texBorder].forEach(t => t.needsUpdate = true);

    if (this.cardMesh) this.scene.remove(this.cardMesh);

    const sideMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
    
    // BACK MATERIAL: Always uses environment map for subtle depth
    const backMat = new THREE.MeshStandardMaterial({ 
        map: texB, 
        envMap: this.envMap,
        roughness: 0.7, 
        metalness: 0.1,
        envMapIntensity: 0.5 
    });

    /**
     * Helper: Material Switcher
     * Now applies environment mapping to both Shader and Standard materials
     */
    const getMaterial = (tex, isHoloEnabled, isTransparent = false) => {
        const isMasterFoil = data.isFoil || data.rarityTier === 'Legendary';
        
        if (isMasterFoil && isHoloEnabled) {
            return new THREE.ShaderMaterial({
                uniforms: {
                    map: { value: tex },
                    envMap2D: { value: this.envMap },
                    uFlakeMap: { value: this.flakeMap },
                    uCameraPos: { value: new THREE.Vector3().copy(this.camera.position) },
                    uFlakesEnabled: { value: 1.0 },
                    uFlakeSize: { value: 1.0 },
                    uFlakeReduction: { value: 0.65 },
                    uFlakeBrightness: { value: 0.18 },
                    uMetalness: { value: 0.4 },
                    uIridescence: { value: 0.8 },
                    uEnvIntensity: { value: 1.2 }
                },
                vertexShader: cardVertexShader,
                fragmentShader: cardFragmentShader,
                transparent: true,
                depthWrite: !isTransparent
            });
        }

        // MATTE / LOW REFLECTIVE MATERIAL
        return new THREE.MeshStandardMaterial({ 
            map: tex, 
            envMap: this.envMap,        // Added EnvMap
            envMapIntensity: 0.4,       // Low intensity for matte look
            transparent: isTransparent, 
            alphaTest: isTransparent ? 0.1 : 0,
            roughness: 0.8,             // High roughness = Matte
            metalness: 0.1              // Low metalness = Non-foil
        });
    };

    // 1. Background
    const frontMat = getMaterial(texF, data.holoBg, false);
    this.cardMesh = new THREE.Mesh(
        new THREE.BoxGeometry(3.5, 5, 0.1), 
        [sideMat, sideMat, sideMat, sideMat, frontMat, backMat]
    );
    this.scene.add(this.cardMesh);

    // 2. Player
    const pMat = getMaterial(texP, data.holoPlayer, true);
    const pMesh = new THREE.Mesh(new THREE.PlaneGeometry(3.5, 5), pMat);
    pMesh.position.z = 0.051; 
    this.cardMesh.add(pMesh);

    // 3. Border
    const bMat = getMaterial(texBorder, data.holoBorder, true);
    const bMesh = new THREE.Mesh(new THREE.PlaneGeometry(3.5, 5), bMat);
    bMesh.position.z = 0.052; 
    this.cardMesh.add(bMesh);
}

        function flipCard() {
            isFlipped = !isFlipped;
            gsap.to(cardMesh.rotation, { y: isFlipped ? Math.PI : 0, duration: 0.6 });
        }

        function downloadCard() {
            const canvas = document.getElementById('hidden-canvas-front');
            const link = document.createElement('a');
            link.download = 'card-front.png';
            link.href = canvas.toDataURL();
            link.click();
        }

        function setupInteraction() {
            let drag = false, prev = {x:0, y:0};
            const vp = document.getElementById('viewport');
            vp.addEventListener('mousedown', e => { drag = true; prev = {x:e.clientX, y:e.clientY}; });
            window.addEventListener('mouseup', () => drag = false);
            window.addEventListener('mousemove', e => {
                if(!drag || !cardMesh) return;
                cardMesh.rotation.y += (e.clientX - prev.x) * 0.01;
                cardMesh.rotation.x += (e.clientY - prev.y) * 0.01;
                prev = {x:e.clientX, y:e.clientY};
            });
            vp.addEventListener('wheel', e => { 
                camera.position.z += e.deltaY * 0.01; 
                camera.position.z = Math.max(5, Math.min(20, camera.position.z));
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            if(cardMesh && document.getElementById('isHolo').checked) {
                const hue = (Date.now() * 0.0005) % 1;
                cardMesh.material[4].emissive.setHSL(hue, 0.5, 0.1);
            }
            renderer.render(scene, camera);
        }

        // Start everything
        init();
        updateCard();
        animate();
    </script>
</body>
</html>